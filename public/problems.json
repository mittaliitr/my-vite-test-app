[
  {
    "number": "721",
    "title": "Accounts Merge",
    "tag": "Graph / Union Find",
    "frequency": "High",
    "code": "/**\n * Given a list accounts, each element accounts[i] is a list of strings, where\n * the first element accounts[i][0] is a name, and the rest of the elements are\n * emails representing emails of the account.\n *\n * Now, we would like to merge these accounts. Two accounts definitely belong\n * to the same person if there is some email that is common to both accounts.\n * Note that even if two accounts have the same name, they may belong to\n * different people as people could have the same name. A person can have any\n * number of accounts initially, but all of their accounts definitely have the\n * same name.\n *\n * After merging the accounts, return the accounts in the following format:\n * the first element of each account is the name, and the rest of the elements\n * are emails in sorted order. The accounts themselves can be returned in any\n * order.\n *\n * Example 1:\n * Input:\n * accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n * Output: [[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n *\n * Explanation:\n * The first and third John's are the same person as they have the common email \"johnsmith@mail.com\".\n * The second John and Mary are different people as none of their email addresses are used by other accounts.\n * We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],\n * ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n *\n * Note:\n *\n * The length of accounts will be in the range [1, 1000].\n * The length of accounts[i] will be in the range [1, 10].\n * The length of accounts[i][j] will be in the range [1, 30].\n *\n */\n\n\npublic class AccountsMerge721 {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        List<List<String>> res = new ArrayList<>();\n\n        Map<String, Set<Set<String>>> map = new HashMap<>();\n\n        for (List<String> acc: accounts) {\n            String name = acc.get(0);\n            if (!map.containsKey(name)) {\n                Set<String> set = new HashSet<>(acc);\n                set.remove(name);\n                Set<Set<String>> setOfSet = new HashSet<>();\n                setOfSet.add(set);\n                map.put(name, setOfSet);\n            } else {\n                Set<Set<String>> toBeMerged = new HashSet<>();\n                Set<Set<String>> setOfSet = map.get(name);\n                Set<String> curr = new HashSet<>(acc);\n                curr.remove(name);\n                for (String email: curr) {\n                    Set<String> found = null;\n                    for (Set<String> e: setOfSet) {\n                        if (e.contains(email)) {\n                            found = e;\n                            break;\n                        }\n                    }\n                    if (found != null) {\n                        setOfSet.remove(found);\n                        toBeMerged.add(found);\n                    }\n                }\n                for (Set<String> s: toBeMerged) {\n                    curr.addAll(s);\n                }\n                setOfSet.add(curr);\n            }\n        }\n\n        for (Map.Entry<String, Set<Set<String>>> en: map.entrySet()) {\n            for (Set<String> es: en.getValue()) {\n                List<String> list = new ArrayList<>(es);\n                java.util.Collections.sort(list);\n                list.add(0, en.getKey());\n                res.add(list);\n            }\n        }\n\n        return res;\n    }\n\n\n    /**\n     * https://leetcode.com/problems/accounts-merge/solution/\n     */\n    int MAX_VAL = 10000;\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n\n        Map<String, String> emailToName = new HashMap<>();\n        Map<String, Integer> emailToId = new HashMap<>();\n\n        DSU dsu = initDSU(accounts, emailToName, emailToId);\n\n        Map<Integer, List<String>> res = new HashMap();\n        for (String email: emailToName.keySet()) {\n            int id = dsu.find(emailToId.get(email));\n            res.computeIfAbsent(id, x -> new ArrayList()).add(email);\n        }\n\n        for (List<String> emails: res.values()) {\n            Collections.sort(emails);\n            emails.add(0, emailToName.get(emails.get(0)));\n        }\n\n        return new ArrayList(res.values());\n    }\n\n\n    private DSU initDSU(List<List<String>> accounts, Map<String, String> emailToName, Map<String, Integer> emailToId) {\n        DSU dsu = new DSU(MAX_VAL+1);\n\n        int id = 0;\n        for (List<String> acc: accounts) {\n            String name = acc.get(0);\n\n            for (int i=1; i<acc.size(); i++) {\n                String email = acc.get(i);\n                emailToName.putIfAbsent(email, name);\n                if (!emailToId.containsKey(email)) {\n                    emailToId.put(email, id);\n                    id++;\n                }\n\n                dsu.union(emailToId.get(acc.get(1)), emailToId.get(email));\n            }\n        }\n\n        return dsu;\n    }\n\n\n    class DSU {\n        int[] parent;\n\n        public DSU(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) parent[i] = i;\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) parent[x] = find(parent[x]);\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            parent[find(x)] = find(y);\n        }\n    }\n\n\n    /**\n     * https://leetcode.com/problems/accounts-merge/discuss/109158/Java-Solution-(Build-graph-+-DFS-search)\n     */\n    public List<List<String>> accountsMerge3(List<List<String>> accounts) {\n        Map<String, String> emailToName = new HashMap<>();\n        Map<String, Set<String>> graph = initGraph(accounts, emailToName);\n\n        Set<String> visited = new HashSet<>();\n        List<List<String>> res = new LinkedList<>();\n\n        for (String email: emailToName.keySet()) {\n            List<String> list = new LinkedList<>();\n            if (visited.add(email)) {\n                dfs(graph, email, visited, list);\n                Collections.sort(list);\n                list.add(0, emailToName.get(email));\n                res.add(list);\n            }\n        }\n\n        return res;\n    }\n\n    private Map<String, Set<String>> initGraph(List<List<String>> accounts, Map<String, String> emailToName) {\n        Map<String, Set<String>> graph = new HashMap<>();\n\n        for (List<String> acc : accounts) {\n            String name = acc.get(0);\n            for (int i = 1; i < acc.size(); i++) {\n                String email = acc.get(i);\n                if (!graph.containsKey(acc.get(i))) {\n                    graph.put(email, new HashSet<>());\n                }\n\n                emailToName.put(email, name);\n\n                if (i == 1) continue;\n                graph.get(email).add(acc.get(i-1));\n                graph.get(acc.get(i-1)).add(email);\n            }\n        }\n        return graph;\n    }\n\n    private void dfs(Map<String, Set<String>> graph, String email, Set<String> visited, List<String> list) {\n        list.add(email);\n        for (String l: graph.get(email)) {\n            if (visited.add(l)) dfs(graph, l, visited, list);\n        }\n    }\n\n\n}\n",
    "companies": [
      "Google",
      "Facebook",
      "Amazon"
    ],
    "difficulty": "Medium",
    "solution_summary": "Use Union Find to merge accounts by email, then reconstruct accounts from connected components.",
    "url": "https://leetcode.com/problems/accounts-merge/",
    "approach": "Group all emails that are connected through shared accounts, so that each group represents one person, then collect and output each person's name with their sorted unique emails.",
    "mainDataStructures": [
      "HashMap: Maps each email to its owner's name.",
      "Graph (Adjacency List) or Union-Find (DSU): Connects/group emails belonging to the same person.",
      "Set: Tracks emails already grouped or visited during traversal."
    ],
    "highLevelPseudocode": [
      "// Build email connections",
      "for each account in accounts:",
      "    name = account[0]",
      "    for each email in account[1:]:",
      "        emailToName[email] = name",
      "        connect email to other emails in the same account (using graph or DSU)",
      "",
      "// Group emails by connected components",
      "initialize visited set",
      "for each email in emailToName:",
      "    if email not in visited:",
      "        group = collect all connected emails (DFS/BFS or DSU)",
      "        mark all in group as visited",
      "        sorted_emails = sort(group)",
      "        merged_account = [emailToName[email]] + sorted_emails",
      "        add merged_account to result",
      "",
      "return result"
    ]
  },
  {
    "number": "722",
    "title": "Accounts Merge2",
    "code": "/**\n * Given a list accounts, each element accounts[i] is a list of strings, where\n * the first element accounts[i][0] is a name, and the rest of the elements are\n * emails representing emails of the account.\n *\n * Now, we would like to merge these accounts. Two accounts definitely belong\n * to the same person if there is some email that is common to both accounts.\n * Note that even if two accounts have the same name, they may belong to\n * different people as people could have the same name. A person can have any\n * number of accounts initially, but all of their accounts definitely have the\n * same name.\n *\n * After merging the accounts, return the accounts in the following format:\n * the first element of each account is the name, and the rest of the elements\n * are emails in sorted order. The accounts themselves can be returned in any\n * order.\n *\n * Example 1:\n * Input:\n * accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n * Output: [[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n *\n * Explanation:\n * The first and third John's are the same person as they have the common email \"johnsmith@mail.com\".\n * The second John and Mary are different people as none of their email addresses are used by other accounts.\n * We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],\n * ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n *\n * Note:\n *\n * The length of accounts will be in the range [1, 1000].\n * The length of accounts[i] will be in the range [1, 10].\n * The length of accounts[i][j] will be in the range [1, 30].\n *\n */\n\n\npublic class AccountsMerge721 {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        List<List<String>> res = new ArrayList<>();\n\n        Map<String, Set<Set<String>>> map = new HashMap<>();\n\n        for (List<String> acc: accounts) {\n            String name = acc.get(0);\n            if (!map.containsKey(name)) {\n                Set<String> set = new HashSet<>(acc);\n                set.remove(name);\n                Set<Set<String>> setOfSet = new HashSet<>();\n                setOfSet.add(set);\n                map.put(name, setOfSet);\n            } else {\n                Set<Set<String>> toBeMerged = new HashSet<>();\n                Set<Set<String>> setOfSet = map.get(name);\n                Set<String> curr = new HashSet<>(acc);\n                curr.remove(name);\n                for (String email: curr) {\n                    Set<String> found = null;\n                    for (Set<String> e: setOfSet) {\n                        if (e.contains(email)) {\n                            found = e;\n                            break;\n                        }\n                    }\n                    if (found != null) {\n                        setOfSet.remove(found);\n                        toBeMerged.add(found);\n                    }\n                }\n                for (Set<String> s: toBeMerged) {\n                    curr.addAll(s);\n                }\n                setOfSet.add(curr);\n            }\n        }\n\n        for (Map.Entry<String, Set<Set<String>>> en: map.entrySet()) {\n            for (Set<String> es: en.getValue()) {\n                List<String> list = new ArrayList<>(es);\n                java.util.Collections.sort(list);\n                list.add(0, en.getKey());\n                res.add(list);\n            }\n        }\n\n        return res;\n    }\n\n\n    /**\n     * https://leetcode.com/problems/accounts-merge/solution/\n     */\n    int MAX_VAL = 10000;\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n\n        Map<String, String> emailToName = new HashMap<>();\n        Map<String, Integer> emailToId = new HashMap<>();\n\n        DSU dsu = initDSU(accounts, emailToName, emailToId);\n\n        Map<Integer, List<String>> res = new HashMap();\n        for (String email: emailToName.keySet()) {\n            int id = dsu.find(emailToId.get(email));\n            res.computeIfAbsent(id, x -> new ArrayList()).add(email);\n        }\n\n        for (List<String> emails: res.values()) {\n            Collections.sort(emails);\n            emails.add(0, emailToName.get(emails.get(0)));\n        }\n\n        return new ArrayList(res.values());\n    }\n\n\n    private DSU initDSU(List<List<String>> accounts, Map<String, String> emailToName, Map<String, Integer> emailToId) {\n        DSU dsu = new DSU(MAX_VAL+1);\n\n        int id = 0;\n        for (List<String> acc: accounts) {\n            String name = acc.get(0);\n\n            for (int i=1; i<acc.size(); i++) {\n                String email = acc.get(i);\n                emailToName.putIfAbsent(email, name);\n                if (!emailToId.containsKey(email)) {\n                    emailToId.put(email, id);\n                    id++;\n                }\n\n                dsu.union(emailToId.get(acc.get(1)), emailToId.get(email));\n            }\n        }\n\n        return dsu;\n    }\n\n\n    class DSU {\n        int[] parent;\n\n        public DSU(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) parent[i] = i;\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) parent[x] = find(parent[x]);\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            parent[find(x)] = find(y);\n        }\n    }\n\n\n    /**\n     * https://leetcode.com/problems/accounts-merge/discuss/109158/Java-Solution-(Build-graph-+-DFS-search)\n     */\n    public List<List<String>> accountsMerge3(List<List<String>> accounts) {\n        Map<String, String> emailToName = new HashMap<>();\n        Map<String, Set<String>> graph = initGraph(accounts, emailToName);\n\n        Set<String> visited = new HashSet<>();\n        List<List<String>> res = new LinkedList<>();\n\n        for (String email: emailToName.keySet()) {\n            List<String> list = new LinkedList<>();\n            if (visited.add(email)) {\n                dfs(graph, email, visited, list);\n                Collections.sort(list);\n                list.add(0, emailToName.get(email));\n                res.add(list);\n            }\n        }\n\n        return res;\n    }\n\n    private Map<String, Set<String>> initGraph(List<List<String>> accounts, Map<String, String> emailToName) {\n        Map<String, Set<String>> graph = new HashMap<>();\n\n        for (List<String> acc : accounts) {\n            String name = acc.get(0);\n            for (int i = 1; i < acc.size(); i++) {\n                String email = acc.get(i);\n                if (!graph.containsKey(acc.get(i))) {\n                    graph.put(email, new HashSet<>());\n                }\n\n                emailToName.put(email, name);\n\n                if (i == 1) continue;\n                graph.get(email).add(acc.get(i-1));\n                graph.get(acc.get(i-1)).add(email);\n            }\n        }\n        return graph;\n    }\n\n    private void dfs(Map<String, Set<String>> graph, String email, Set<String> visited, List<String> list) {\n        list.add(email);\n        for (String l: graph.get(email)) {\n            if (visited.add(l)) dfs(graph, l, visited, list);\n        }\n    }\n\n\n}\n",
    "tag": "Graph / Union Find",
    "frequency": "High",
    "companies": [
      "Facebook",
      "Amazon"
    ],
    "difficulty": "Hard",
    "solution_summary": "Use Union Find to merge accounts by email, then reconstruct accounts from connected components.",
    "url": "https://leetcode.com/problems/accounts-merge/",
    "approach": "Group all emails that are connected through shared accounts, so that each group represents one person, then collect and output each person's name with their sorted unique emails.",
    "mainDataStructures": [
      "HashMap: Maps each email to its owner's name.",
      "Graph (Adjacency List) or Union-Find (DSU): Connects/group emails belonging to the same person.",
      "Set: Tracks emails already grouped or visited during traversal."
    ],
    "highLevelPseudocode": [
      "// Build email connections",
      "for each account in accounts:",
      "    name = account[0]",
      "    for each email in account[1:]:",
      "        emailToName[email] = name",
      "        connect email to other emails in the same account (using graph or DSU)",
      "",
      "// Group emails by connected components",
      "initialize visited set",
      "for each email in emailToName:",
      "    if email not in visited:",
      "        group = collect all connected emails (DFS/BFS or DSU)",
      "        mark all in group as visited",
      "        sorted_emails = sort(group)",
      "        merged_account = [emailToName[email]] + sorted_emails",
      "        add merged_account to result",
      "",
      "return result"
    ]

  }
]